#+TITLE: Setting up a full stack clj / cljs project from scratch
#+STARTUP: indent overview
#+OPTIONS: toc:nil num:nil ^:nil html-postamble:nil
#+PROPERTY: header-args :mkdirp yes

* Introduction
We will create a ~product-ui~ project that has a backend server
written in clojure and a frontend SPA written in clojurescript.

* General required software
- JVM

* Leiningen project for the backend http server
** Required software
- [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein][lein script]] executable on the users path

** Generate a minimal project with the lein app template
We want to implement the host for our frontend SPA in clojure. It will
serve static html, css and js assets, and handle ajax requests from
the SPA.

The following script creates a minimal ~product-ui~ project for a
clojure application with a main function. The project is created under
the ~~/playground/~ folder. To ensure a blank slate, if a ~product-ui~
folder exists at this location already, it is deleted first.

#+begin_src sh :dir ~/playground/ :results none
  rm -rf product-ui
  lein new app product-ui
#+end_src

** Clean up in the generated project
Let's clean up a bit more, we don't need some of the file and folders
that were generated by ~lein~ for now.

#+begin_src sh :dir ~/playground/product-ui :results none
  rm -rf CHANGELOG.md LICENSE README.md doc test
#+end_src

The ~project.clj~ file that was generated can be simplified by
removing the ~:description~, ~:url~ and ~:license~ key-value pairs.

We can then move the generated core.clj file and adjust its namespace
declaration to ~product-ui.backend.server~, and change it in the project.clj file as well.

#+begin_src sh :dir ~/playground/product-ui :results none
  mkdir -p src/product_ui/backend
  mv src/product_ui/core.clj src/product_ui/backend/server.clj
  sed -i 's/product-ui.core/product-ui.backend.server/g' project.clj src/product_ui/backend/server.clj
  #+end_src

The backend folder will contain clojure namespaces. Later we will add
a frontend folder to our project for our frontend clojurescript
namespaces.

It should now be possible to start a repl in the
~product-ui.backend.server~ namespace and test the ~-main~ function.

It should also be possible to build an uberjar

#+begin_src sh :dir ~/playground/product-ui
  lein uberjar
#+end_src

and run the resulting jar.

#+begin_src sh :dir ~/playground/product-ui
  java -jar target/uberjar/product-ui-0.1.0-SNAPSHOT-standalone.jar
#+end_src

** Add dependencies to the lein project.clj file
Update to the latest clojure release, and add some extra dependencies,
by editing ~:dependencies~ value in ~project.clj~ to become as
follows.

#+begin_src clojure
  [[org.clojure/clojure "1.11.1"]
   [ring/ring-core "1.9.5"]
   [ring/ring-jetty-adapter "1.9.5"]
   [metosin/reitit "0.5.5"]]
#+end_src

- ring/ring-core

  Ring will be the base of our server-side http stack. It basically
  provides infrastructure to handle incoming http requests. An
  incoming request is translated into a clojure map data structure
  that describes the request. This map is then passed to a user
  provided handler function. It is the responsibility of this handler
  to produce a clojure map that describes the desired http response
  for the request. Ring then translates this map into an http response
  that gets returned to the client.

- ring/ring-jetty-handler

  Ring can be combined with several http server implementations. We
  will host our own jetty http server in the JVM process. The
  ~ring-jetty-handler~ package provides the jetty server and logic to
  integrate ~ring-core~ with it.

- metosin/reitit

  While it is possible to just write a handler function that inspects
  the incoming http request and based on the request uri execute
  different logic, soon it becomes more practical to use a good
  routing library. It will for example inspect of the ~:uri~ value in
  the request map, parse path and query string parameters out of it,
  and invoke a function that is specified for the route it resolved.
  Router libraries can also include functionality for static file
  serving, 404 and redirect handling, and much more.

  While ~compojure~ once was common place, and it still is used quite
  a lot, ~reitit~ has become popular. Just some of the reasons for
  this are that it keeps routes as pure data (as apposed to opaque
  macros), it provides bi-directional routing and it has a strong
  focus on performance.

** Serve some static content
Rework the ~product-ui.backend.server~ namespace to become as follows.

#+begin_src clojure
  (ns product-ui.backend.server
    (:require [reitit.ring :as rr]
              [ring.adapter.jetty])
    (:gen-class))

  (def handler
    (rr/ring-handler
     (rr/router [])
     (rr/routes
      (rr/create-resource-handler {:path "/"})
      (rr/create-default-handler))))

  (defn- start-server
    []
    (ring.adapter.jetty/run-jetty #'handler {:port 8123
                                             :join? false}))

  (defn -main
    [& args]
    (println "Starting server.")
    (let [server (start-server)]
      (println "Server started. Press <enter> to terminate.")
      (read-line)
      (.stop server)
      (println "Server stopped.")))
#+end_src

We create a ring-handler by using a function provided by reitit. It
takes a router with custom routes, at the moment we don't define any,
and optionally some default routes. We register a resource-handler to
serve static files. By default resources under a 'public' root folder
are served by this handler. By default index.html is served for the
root of the website. This setup will also handle 404 not found and
other situations.

We then define a helper function that starts a jetty server that uses
the new handler and returns the server. The -main function starts the
server and waits for an 'enter' press to stop the server and the
program.

Let's add 2 static files, an index.html file and a styles.css file.
index.html goes directly under 'public' under resources, styles.css is
put in a css sub-directory of 'public'.

So file ~/playground/product-ui/resources/public/index.html.

#+begin_src html
  <!DOCTYPE html>
  <html>
    <head>
      <title>Frontend UI</title>
      <link rel="stylesheet" href="/css/styles.css">
    </head>
    <body>
      <h1>Frontend UI</h1>
      <p>
        A static html file.
      </p>
    </body>
  </html>
  #+end_src

And file ~/playground/product-ui/resources/public/css/styles.css

#+begin_src css
  body {
      padding: 3em;
      color: #228811;
  }
#+end_src

We can now start the server from a running repl. While being in the
~product-ui.backend.server~ namespace, evaluate the following.

#+begin_src clojure
  (def server (start-server))
#+end_src

And access http://locahost:8123. It works, but we got redirected to
/index.html. We can inspect the workings of the handler function
directly from the repl as follows. We just create 'request' maps as
ring would provide them to the handler. The results are the response
maps that ring would use to create the html response.

#+begin_src clojure
  (handler {:request-method :get
            :uri "/"})
  ;; -> {:status 302, :headers {"Location" "/index.html"}, :body ""}


  (handler {:request-method :get
            :uri "/index.html"})
  ;; ->
  ;; {:status 200,
  ;;  :headers
  ;;  {"Content-Length" "219",
  ;;   "Last-Modified" "Sun, 29 May 2022 10:11:12 GMT",
  ;;   "Content-Type" "text/html"},
  ;;  :body
  ;;  #object[java.io.File 0x5e6a59c8 "~/playground/product-ui/resources/public/index.html"]}
#+end_src

* Adding a shadow-cljs SPA
** Required software
- nodejs
- npm

** Requiring shadow-cljs and reagent dependencies in project.clj
We want to use the shadow-cljs toolset for compilation from
clojurescript to javascript, enable hot reloading while developing and
generating a final minimized compilation artifact when we want to
release the project. shadow-cljs offers more which we'll look at
later.

shadow-cljs can be used via node but it is also distributed as a java
jar so we can just reference it from project.clj. We will also include
reagent which wraps the react javascript framework in a clojurescript
friendly way.

None of the dependencies we use to work with clojure script will be
required at runtime when our project is deployed. The final
deliverable of our project will be a single jar containing the server
and some static files, some of them javascript files created by the
shadow-cljs compiler. We can therefore keep these dependencies in the
~:dev~ profile in project.clj. We also add an extra resource-path
'dev' in this profile so that the contents of this folder is on our
classpath while developing in the repl. By default, leiningen will put
the "src" and "resources" folders on the classpath, and also include
the "test" folder for certain profiles like "dev".

Add the following profile at the same level as the existing ~:uberjar~
profile (in the map under the root ~:profiles~ key).

#+begin_src clojure
  :dev {:dependencies [[thheller/shadow-cljs "2.19.0"]
                       [reagent/reagent "1.1.1"]]
        :resource-paths ["dev"]}
#+end_src

The shadow-cljs clojurescript repl isn't normally nrepl based. To make
it work correctly from inside an nrepl provided by leiningen, we need
a final addition to the project.clj file to register some nrepl
middleware provided by shadow-cljs. Add a ~:repl-options~ key in the
root of the project.clj file, I added mine on a new line under the
~:target-path~ key.

#+begin_src clojure
  :repl-options {:nrepl-middleware [shadow.cljs.devtools.server.nrepl/middleware]}
#+end_src

That's all for now in project.clj.

** Include react and react-dom as node packages
reagent itself requires react and react-dom but does not include it.
These could be added as dependencies in project.clj, but in
shadow-cljs it is preferred to include them as node packages. This
also showcases that it is easy to include node packages in the
clojurescript project. Execute the following in project root.

#+begin_src sh :dir ~/playground/product-ui :results none
  npm install react react-dom
#+end_src

This will create the node_modules folder, and the expected
package.json and package-lock.json files. That's it, react and
react-dom will be available for reagent when we start using it
shortly.

** shadow-cljs.edn build configuration file
shadow-cljs searches for a ~shadow-cljs.edn~ file with build
configurations in the root of the project tree. Create
~~/playground/product-ui/shadow-cljs.edn~ as follows.

#+begin_src clojurescript
  {:lein true

   :builds
   {:frontend {:target :browser
               :modules {:main {:init-fn product-ui.frontend.app/init}}
               :output-dir "resources/public/js"
               :asset-path "/js"
               :devtools {:watch-dir "resources/public"}}}}
#+end_src

Setting the ~:lein~ key to true indicates to shadow-cljs that all
clojure/java dependencies and classpath generation will be handled by
leiningen. shadow-cljs by default can also do this, but we prevent
this here to have leiningen take control.

We defined a single build ~:frontend~ and defined it to target a
browser, shadow-cljs has other target for node development etc. We
want a single javascript file (defined under ~:modules~) 'main.js' to
be produced that starts its live (~:init-fn~) in the init function
defined in the ~product-ui.frontend.app~ namespace. The produced
javascript should be emitted under ~resources/public/js~. The
asset-path should state the path from the root of the application. We
know that ~resources/public~ is served from the root of our
application (for static content described above), so we state ~/js~ as
the asset-path. With the included ~:devtools~ ~:watch-dir~, we make
shadow-cljs monitor the folder containing all of our static content,
and enables hot reloading of eg. our css file.

** Update the index.html file to use main.js
We know now that our javascript will be served from ~/js/main.js~. It
will require a div with id 'app' to render its content in (using
react).

Rework the index.html file to be as follows.

#+begin_src html
  <!DOCTYPE html>
  <html>
    <head>
      <title>Frontend UI</title>
      <link rel="stylesheet" href="/css/styles.css">
    </head>
    <body>
      <div id="app"></div>
      <script src="js/main.js"></script>
    </body>
  </html>
#+end_src

** Add the first clojurescript file
We configured the ~:frontend~ build to use the
~product-ui.frontend.app~ namespace. Create file
~~/playground/product-ui/src/product_ui/frontend/app.cljs~. The cljs
extension indicates that this is a clojurescript file.

#+begin_src clojurescript
  (ns product-ui.frontend.app
    (:require [reagent.core :as reagent]
              [reagent.dom :as reagent-dom]))

  (defonce the-state
    (reagent/atom {:text "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
                   :current-count 0}))

  (defn app
    []
    (let [{:keys [text current-count]} @the-state]
      [:div
       [:h1 (str text " -- " current-count)]
       [:button
        {:on-click (fn [_ev]
                     (swap! the-state
                            (fn [state]
                              (-> state
                                  (update :text #(apply str (rest %)))
                                  (update :current-count inc)))))}
        "Push Me"]]))

  (defn init
    []
    (reagent-dom/render [app] (js/document.getElementById "app")))
#+end_src

~the-state~ is defonce'd, so existing state isn't destroyed when hot
reloading occurs. ~app~ seems to be a function, but it is actually a
react component. The component depends on the ~the-state~ (it is
dereferenced) so it will be rerendered as necessary when ~the-state~
gets updated. A 'Push Me' button does exactly that, make some changes
to the state. We promised an ~init~ function in our shadow-cljs build
configuration, we include it to render our component in the 'app' div.
Notice that we don't call ~(app)~ but pass the component in a vector.

Let's test if compilation works. We'll soon start shadow-cljs from a
leiningen repl, but for now we'll just quickly run the :frontend build
configuration with the compile command to create the (non-optimized)
main.js file and its dependencies in the correct ~js~ folder under
~resources/public~.

#+begin_src sh :dir ~/playground/product-ui :results none
  npx shadow-cljs compile :frontend
#+end_src

It should now be possible to reload the page at
http://localhost:8123/index.html (if the server is still running) and
see the application running.

** user namespace under dev for helper functions
When a clojure repl starts, if a user namespace is found in the root
of the class path it will get auto-loaded. We added the "dev" folder
as a resource-path in project.clj. Add the following
~~/playground/product-ui/dev/user.clj~ clojure file.

#+begin_src clojure
  (ns user
    (:require [shadow.cljs.devtools.server :as shadow-server]
              [shadow.cljs.devtools.api :as shadow]))

  (defn start-cljs-repl
    []
    (shadow-server/start!)
    (shadow/watch :frontend)
    (shadow/repl :frontend))

  (defn build-cljs-release
    []
    (shadow/release :frontend))
  #+end_src

~start-cljs-repl~ allows us to launch shadow-cljs in watch mode to
recompile our clojurescript files each time they are saved, and have
the new code hot-loaded in the browser. It then switches to a
clojurescript repl. Let's try it.

If you have a repl running in the project stop it now and open the
server.clj file in the project. Launch a new repl. Select ~lein~ for
the repl type if asked. The clojure repl starts in the
product-ui-backend-server namespace. Let's start the http server,
evaluate the following in the repl.

#+begin_src clojure
  (def server (start-server))
#+end_src

Even though our repl starts in the product-ui.backend-server
namespace, the user namespace should already be loaded. Try therefore
the following from the repl.

#+begin_src clojure
  (user/start-cljs-repl)
#+end_src

We should end up in a clojurescript repl, the prompt should show
something like ~cljs.user>~. Reload http://localhost:8123/index.html
in the browser and we should be connected. Test the following in the
cljs repl.

#+begin_src clojurescript
  (+ 1 2 3)
  ;; -> 6

  (= 1 1.0)
  ;; -> true
#+end_src

The last expression evaluating to true is a sign of the code being
executed on the javascript engine in the browser. javascript only has
a floating point numeric type. In clojure on the jvm the result would
be ~false~. Try the following as well.

#+begin_src clojurescript
  (js/alert "Hello")
#+end_src

All standard javascript functions and objects (from the 'window' root)
are available via the ~js/~ prefix.

** Improving code hot reloading

Try to open the style.css file and make a change. When saving the file
the changes should be immediately observable in the browser
application.

Now open the app.cljs file and change the buttons label from "Push Me"
to "Push You" and save the file. A small icon shortly shows that
shadow-cljs pushed updates to the browser, but our button isn't
updated.

Now in app.cljs, make a minor change to the definition of the init
function, adding some metadata to the var. init should look like this.

#+begin_src clojurescript
  (defn ^:dev/after-load init
    []
    (reagent-dom/render [app] (js/document.getElementById "app")))
#+end_src

And save the file again. This time our updates become visible in the
browser, including the changed "Push You" button. The metadata informs
shadow-cljs to invoke the function after a code reload, thereby
re-rendering the root ~app~ component. Now our dynamic development
environment is set up.

** share code between clj/cljs
cljc files can be compiled in a clojure or a clojurescript context, or
in both. We would probably keep our domain logic in a separate project
so that we can reuse it in other backend services, but we can
demonstrate it here by adding a new ~domain.calculations~ namespace.
Add the ~~/playground/product-ui/src/domain/calculations.cljc~ file.

#+begin_src clojure
  (ns domain.calculations)

  (defn average
    [& nums]
    (if (seq nums)
      (double (/ (reduce + nums)
                 (count nums)))
      0))
#+end_src

Save and evaluate the file, and go back to the app.cljs file. Add a
requirement to the namespace ~[domain.calculations :as calcs]~ and
change the ~current-count~ expression in the H1 content to become
~(calcs/average current-count 200)~, so the line becomes.

#+begin_src clojure
  [:h1 (str text " -- " (calcs/average current-count 200))]
#+end_src

When saving the file, the count in the header changes immediately, and
no state was lost in the process. Pressing the button a few times and
then reverting the last code change shows that the counter value and
the title text are still the same as before hot loading the new code.

We can also directly use the generated javascript from the browser js
console. Just type ~domain.calculations.average(3, 4)~ and press
enter, javascript answers ~3.5~.

** Getting back to the clojure repl
Type ~:cljs/quit~ in the clojurescript repl. You'll be back in the
clojure repl. You could now from the repl run ~(require
'[domain.calculations :as calcs])~ and test if the namespace also
works in clojure/java land ~(calcs/average 3 4)~.

** release build
Until now, the main.js file served by our application isn't minimized,
and lots of other artifacts have been generated to enable the
development experience. Being back in the clojure repl type

#+begin_src clojure
  (user/build-cljs-release)
#+end_src

Shadow cljs recompiles all of our clojurescript code and hands it,
together with javascript from included packages, of to the google
~closure~ javascript-to-javascript compiler that treats it with
advanced compilation. When the step is completed, refresh the app in
the browser and inspect the javascript file that is served now. A
single minified main.js file containing all of the logic we used from
clojurescript, react, etc...

Go to a terminal window in the root of the project and execute the
following.

#+begin_src sh :dir ~/playground/product-ui :results none
  npx shadow-cljs release :frontend
  lein uberjar
#+end_src

The first line is superfluous at the moment, it does the same thing we
just did from the clojure repl, but now via the shadow-cljs node
package. leiningen then builds a standalone uberjar, creating a single
artifact for our application server. Make sure that the clojure repl
is stopped, as we want to run the created uberjar and it will try to
use port 8123 that we hard-coded. Try refresh the app in the browser
and you should get an error about a refused connection on localhost.
Now run the following.

#+begin_src sh :dir ~/playground/product-ui :results none
  java -jar target/uberjar/product-ui-0.1.0-SNAPSHOT-standalone.jar
#+end_src

The app is up and running again, press <enter> to stop the server
again.

** The shadow-cljs UI
shadow-cljs hosts its own server at http://localhost:9630 where it
shows details about the processes and builds it is running. The
~Inspect Stream~ and ~Inspect Latest~ tabs work as tap sinks (see
clojure ~tap>~ function). Using ~tap>~ from either a clojure or
a clojurescript context will result in the values tapped being shown
in the UI, ready for inspection.
