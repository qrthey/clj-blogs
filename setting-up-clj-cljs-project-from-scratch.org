#+TITLE: Setting up a full stack clj / cljs project from scratch
#+STARTUP: indent overview
#+OPTIONS: toc:nil num:nil ^:nil html-postamble:nil
#+PROPERTY: header-args :mkdirp yes

* Introduction

** Purpose

This document describes one way of setting up a full stack
clojure/clojurescript web application. It tries to keep the involved
configuration minimal, with all included parts explained.

The setup also showcases how to interactively evolve the application
while it is running, connected to a clojure and a clojurescript repl,
and how to package it for deployment.

** Running example

To be pragmatic, the setup is described by means of a guide that sets
up an imaginary web application, the 'AVG' product (avg-sample-site).
The result is a self-hosted SPA for computing averages of numbers. The
clojurescript frontend focuses on UI (don't expect fancy styling
though), while it communicates with the backend clojure service for
the latter to perform the actual 'hard' averages computations.

Interaction between the frontend and the backend is done via ajax
calls that use transit encoding, enabling sending and receiving
clojure values seamlessly between the clojurescript frontend and the
clojure backend.

The examples suppose that a unix like system such as Gnu/Linux or
macOS is in use. It shouldn't be too difficult to adopt the commands
for a windows environment, but your millage may vary.

** Not in scope

As the focus is on a minimal setup for getting up and running with a
full stack SPA using clojure and clojurescript, the following issues
are not in scope for the setup description. Each of these probably
warrant a separate guide.

- Building out a complex SPA with lots of interacting components.
  Simple examples that can be elaborated on are provided though.
- Security considerations such as
  - where to host the application
  - user authentication
  - hosting with SSL certificates

* Prerequisites

In order to follow along with this guide, the following software is
required on the developer machine. The way to install these is system
dependent, and isn't detailed here, but some links to more information
are included.

- JVM (Java Virtual Machine) as clojure runs on top of it. This is
  also the only runtime requirement.
- leiningen (leiningen.org) as it is used as the clojure project
  management tool. Only required during development and by build
  processes.
- npm (node package manager) (nodejs.org) as npm is used to install
  node packages such as react. Only required during development and in
  build processes.

So before continuing, check if each of the following commands can be
invoked from the terminal. Each will have different output, but it
shouldn't be along the lines of 'command not found'.

#+begin_src sh
  java
  lein
  npm
#+end_src

* Setting up a leiningen app project for the backend

** Generate a minimal project with the lein app template

The backend for the SPA is programmed in clojure. It serves static
html, css and js (javascript) files, and handles ajax requests that
the SPA frontend issues.

The following command creates a minimal ~avg-sample-site~ app project,
i.e. it gets a main function serving as the entry point for the
application executable. Run this command from a directory in which the
project should be created.

#+begin_src sh
  lein new app avg-sample-site
#+end_src

** Clean up in the generated project

Navigate into the new avg-sample-site project directory.

#+begin_src sh
  cd avg-sample-site
#+end_src

Let's clean up a bit. First remove most of the auto generated files
and directories as they aren't strictly necessary for now.

#+begin_src sh
  rm -rf CHANGELOG.md LICENSE README.md doc test .hgignore
#+end_src

The file structure of the project contains a single ~core.clj~ source
file and a project.clj file. The resources directory is empty for now
but will be used later on.

#+begin_src text
  .
  ├── project.clj
  ├── resources
  └── src
      └── avg_sample_site
          └── core.clj
#+end_src

Now open the ~project.clj~ file and simplify it by removing the
~:description~, ~:url~ and ~:license~ key-value pairs. Ensure the
clojure dependency to be up to date, at the time of writing this is
version "1.12.0". The resulting ~project.clj~ file should be as
follows.

#+begin_src clojure
  (defproject avg-sample-site "0.1.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.12.0"]]
    :main ^:skip-aot avg-sample-site.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all
                         :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
#+end_src

** Restructure the project

Leiningen created a project having a src directory with a single
clojure file.

~avg-sample-site/src/avg_sample_site/core.clj~

This file contains the ~avg-sample-site.core~ clojure namespace
(clojure namespaces must be located on disk relative to source
directories, though the names of the directories and files must use
underscores in stead of dashes). Let's change the structure to have a
~avg-sample-site.backend.server~ namespace. Doing this requires us to
also update the project.clj file to point once again to the correct
namespace that contains the main function.

To do this, to following commands can be issued from the
avg-sample-site project root directory.

#+begin_src sh
  mkdir -p src/avg_sample_site/backend
  mv src/avg_sample_site/core.clj src/avg_sample_site/backend/server.clj
  sed -i 's/avg-sample-site.core/avg-sample-site.backend.server/g' project.clj src/avg_sample_site/backend/server.clj
#+end_src

The directory structure is now

#+begin_src text
  .
  ├── project.clj
  ├── resources
  └── src
      └── avg_sample_site
          └── backend
              └── server.clj
#+end_src

And the ~project.clj~ and ~server.clj~ files have been updated to
reflect the new namespace structure.

It should now be possible to start a repl in the
~avg-sample-site.backend.server~ namespace and test its ~-main~
function. So try this.

It should also be possible to build an uberjar from the project root
directory.

#+begin_src sh
  lein uberjar
#+end_src

and run the resulting jar.

#+begin_src sh
  java -jar target/uberjar/avg-sample-site-0.1.0-SNAPSHOT-standalone.jar
#+end_src

If all is well, the 'Hello, World!' is printed and the program exists.

** Add dependencies to the leiningen project.clj file

Update the project.clj file to use the latest clojure release, and add
some extra dependencies, by editing the ~:dependencies~ section in
~project.clj~ to the following. If newer versions are available be
free to try them out.

#+begin_src clojure
  [[org.clojure/clojure "1.12.0"]
   [ring/ring-core "1.12.2"]
   [ring/ring-jetty-adapter "1.12.2"]
   [metosin/reitit "0.7.2"]]
#+end_src

Don't be fooled by the seemingly minimal amount of dependencies
though. Running the following command shows a visually representation
of the inherent transitive dependencies for the project as it is right
now. About 80 dependencies are listed.

#+begin_src sh
  lein deps :tree
#+end_src

A small description for each of the explicitly referred dependencies
follows. ~org.clojure/clojure~ is obvious, we depend on clojure; it is
the programming language for the project.

~ring-core~ is a library that models the task of an HTTP server as a
single function. The function takes a clojure map describing an
incoming request, and it should return a clojure map describing the
outgoing response. In other words, requests and responses are
described by tangible data. Using this library, the user must supply
this function. ring then takes care of translating an incoming request
into a map, invoking the function with it, and translating the
resulting map back into an http response.

~ring-jetty-adapter~ depends on jetty to create an HTTP server that
listens for incoming requests, and integrates it with the ring HTTP
model for request handling.

~metosin/reitit~ is used in this guide to define routes for requests,
used to invoke specific functionality based on the requested URI, and
to include middleware for handling generic transformations for
incoming requests or outgoing responses. It also makes some default
functionality available for serving static content, redirecting,
handling of '404 not found' responses, etc. The configuration of the
reitit routes will result in the single function that the ring model
expects, as described above.

** Serve some static content

Rework the ~avg-sample-site.backend.server~ namespace to become as
follows.

#+begin_src clojure
  (ns avg-sample-site.backend.server
    (:require [reitit.ring :as rr]
              [ring.adapter.jetty])
    (:gen-class))

  (def handler
    (rr/ring-handler
     (rr/router [])
     (rr/routes
      (rr/create-resource-handler {:path "/"})
      (rr/create-default-handler))))

  (defn- start-server
    []
    (ring.adapter.jetty/run-jetty #'handler {:port 8123
                                             :join? false}))

  (defn -main
    [& args]
    (println "Starting server.")
    (let [server (start-server)]
      (println "Server started. Press <enter> to terminate.")
      (read-line)
      (.stop server)
      (println "Server stopped.")))
#+end_src

A reitit ring-handler (a function abiding to the ring model described
above) is created by using the function of the same name provided by
reitit. It takes a router with custom routes, but none are define for
now. A resource-handler is included to serve static files found under
the 'public' directory in resources (avg-sample-site/resources/public)
from the root of the host. Finally a default-handler is added to take
care of handling basic things like 404 not found responses,
redirection from '/' to '/index.html' etc.

Then a helper function is defined that starts a jetty/ring HTTP server
with the handler function, returning the server object. The -main
function starts the server and awaits some user input to then to stop
the server again. When that happens the program also exists as the
~-main~ function contains no more instructions.

Let's serve 2 static files, an ~index.html~ file and a ~styles.css~
file, under the ~public~ resources directory. ~index.html~ goes
directly under 'public' under resources, styles.css is put in a ~css~
sub-directory of ~public~.

So create the ~public~ and ~public/css~ directories under
~avg-sample-site/resources~ if it doesn't exist yet. The following can
be executed from the project root directory used to do so.

#+begin_src shell
  mkdir -p resources/public/css
#+end_src

Then create file avg-sample-site/resources/public/index.html with the
following content.

#+begin_src html
  <!DOCTYPE html>
  <html>
    <head>
      <title>AVG Sample</title>
      <link rel="stylesheet" href="/css/styles.css">
    </head>
    <body>
      <h1>AVG</h1>
      <p>
        A static html file.
      </p>
    </body>
  </html>
  #+end_src

And likewise for the file avg-sample-site/resources/public/css/styles.css.

#+begin_src css
  body {
      padding: 3em;
  }

  h1 {
      color: blue;
  }
#+end_src

We can now start the server from a running repl. In the
~avg-sample-site.backend.server~ namespace, evaluate the following.

#+begin_src clojure
  (def server (start-server))
#+end_src

Opening a browser and navigating to http://locahost:8123 should result
in a redirection to /index.html where the basic html page with its
styling is displayed.

From the repl, we can check the workings of the handler function
directly by passing it a ring request map, and inspecting the
resulting response map. For example how the request to the root of the
application host redirects to ~/index.html~, and how that subsequent
request is handled.

#+begin_src clojure
  (handler {:request-method :get
            :uri "/"})
  ;; -> {:status 302, :headers {"Location" "/index.html"}, :body ""}


  (handler {:request-method :get
            :uri "/index.html"})
  ;; ->
  ;; {:status 200,
  ;;  :headers
  ;;  {"Content-Length" "210",
  ;;   "Last-Modified" "Mon, 04 Nov 2024 19:58:20 GMT",
  ;;   "Content-Type" "text/html"},
  ;;  :body
  ;;  #object[java.io.File 0x78ef9ab7 "...../avg-sample-site/resources/public/index.html"]}
#+end_src

* Adding a shadow-cljs (clojurescript) frontend SPA

** Requiring shadow-cljs and reagent dependencies in project.clj

We want to use the shadow-cljs toolset for compiling clojurescript
into javascript, enable hot reloading while developing, and generating
a final minimized javascript compiled artifact when we want to release
the project. shadow-cljs offers more functionality that we'll look at
as well.We also want to use reagent, a clojurescript friendly wrapper
for the react javascript framework.

These clojurescript libraries and tools aren't required, nor desired,
at runtime though. The final deliverable of our project will be a
single jar containing the server logic and some static files, some of
them javascript files produced by the shadow-cljs compiler.

We can therefore define the dependencies for shadow-cljs and reagent
in the ~:dev~ profile in project.clj. This makes them available in a
repl session, and when running the build process (uberjar).
shadow-cljs itself will also use this profile when building
clojurescript files. But the dependencies will not be included in
produced artifacts.

We also add an extra resource-path 'dev' in the ~:dev~ profile, so
that the contents of this directory is on our classpath while
developing in the repl. We will later define a utility namespace in
this directory that is only relevant during development.

In the project.clj file at the root of the project, add the following
profile at the same level as the existing ~:uberjar~ profile (in the
map under the root ~:profiles~ key).

#+begin_src clojure
  :dev {:dependencies [[thheller/shadow-cljs "2.28.15"]
                       [reagent/reagent "1.2.0"]]
        :resource-paths ["dev"]}
#+end_src

The shadow-cljs clojurescript repl isn't normally nrepl based. To make
it work correctly from inside an nrepl provided by leiningen, we need
a final addition to the project.clj file to register some nrepl
middleware provided by shadow-cljs. Add a ~:repl-options~ key in the
root of the project.clj file, for example as a new line under the
~:target-path~ key.

#+begin_src clojure
  :repl-options {:nrepl-middleware [shadow.cljs.devtools.server.nrepl/middleware]}
#+end_src

That's all for now in project.clj.

** Include react and react-dom as node packages

reagent itself requires react and react-dom javascript libraries, but
does not include them. These could be added as dependencies in
project.clj, but in shadow-cljs it is preferred to add them to the
project as node packages. This also showcases how easy it is to
include node packages in the clojurescript project, should you want to
include more later on. Execute the following in project root.

#+begin_src sh
  npm install react react-dom
#+end_src

This will create a node_modules directory (which can be gitignored), a
package.json file, and a package-lock.json file. That's it, react and
react-dom will be available for reagent when we start using it
shortly.

** shadow-cljs.edn build configuration file

shadow-cljs searches for a ~shadow-cljs.edn~ file with build
configurations in the root of the project tree. Create
~avg-sample-site/shadow-cljs.edn~ as follows.

#+begin_src clojurescript
  {:lein true

   :builds
   {:frontend {:target :browser
               :modules {:main {:init-fn avg-sample-site.frontend.app/init}}
               :output-dir "resources/public/js"
               :asset-path "/js"
               :devtools {:watch-dir "resources/public"}}}}
#+end_src

Setting the ~:lein~ key to true indicates to shadow-cljs that all
clojure/java dependencies and classpath generation will be handled by
leiningen. shadow-cljs can also take care of this, but the
configuration allows for leiningen to take control, as a custom
backend server is to be start.

A single build ~:frontend~ is defined to target a browser; shadow-cljs
has other target for node development etc. A single 'main.js'
javascript file will be the output of this build, as defined by the
key under ~:modules~. This javascript file will invoke the ~:init-fn~
specified when it is loaded.

The produced javascript is to be emitted under ~resources/public/js~.
The asset-path states the path for the emitted javascript file(s) from
the root of the application host server. We know that
~resources/public~ is served from the root of our application (for
static content described above), so we state ~/js~ as the asset-path.

With the included ~:devtools~ ~:watch-dir~, we make shadow-cljs
monitor the directory containing all of our static content (~public~),
and enable hot reloading of changed files such as the ~styles.css~
file and javascript files produced by shadow-cljs when compiling
clojurescript.

** Update the index.html file to use main.js

Our javascript application will be available from the application host
root at ~/js/main.js~. It will require a div with id 'app' to render
its content in (using react).

Rework the index.html file as follows.

#+begin_src html
  <!DOCTYPE html>
  <html>
    <head>
      <title>AVG Sample</title>
      <link rel="stylesheet" href="/css/styles.css">
    </head>
    <body>
      <div id="app"></div>
      <script src="js/main.js"></script>
    </body>
  </html>
#+end_src

** Add the first clojurescript file

The ~:frontend~ build was configured to use the
~avg-sample-site.frontend.app~ namespace. Create the file for that
namespace at ~avg-sample-site/src/avg_sample_site/frontend/app.cljs~
(create the front sub-directory in the project if it doesn't exist
yet). The cljs extension indicates that this is a clojurescript file.

#+begin_src clojurescript
  (ns avg-sample-site.frontend.app
    (:require [reagent.core :as reagent]
              [reagent.dom :as reagent-dom]))

  (defonce the-state
    (reagent/atom {:text "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
                   :current-count 0}))

  (defn app
    []
    (let [{:keys [text current-count]} @the-state]
      [:div
       [:h1 (str text " -- " current-count)]
       [:button
        {:on-click (fn [_ev]
                     (swap! the-state
                            (fn [state]
                              (-> state
                                  (update :text #(apply str (rest %)))
                                  (update :current-count inc)))))}
        "Push Me"]]))

  (defn init
    []
    (reagent-dom/render [app] (js/document.getElementById "app")))
#+end_src

~the-state~ is defonce'd, so existing state isn't destroyed when hot
reloading occurs. ~app~ seems to be a function, but it is actually a
react component. The component depends on the ~the-state~ (it is
dereferrenced) so it will be re-rendered as necessary when ~the-state~
gets updated. A 'Push Me' button does exactly that, make some changes
to the state. We promised an ~init~ function in our shadow-cljs build
configuration, we include it to render our component in the 'app' div.
Notice that we don't call ~(app)~ but pass the component in a vector.

Let's test if compilation works. We'll soon start shadow-cljs from a
leiningen repl, but for now we'll just quickly run the :frontend build
configuration with the compile command to create the (non-optimized)
main.js file and its dependencies in the correct ~js~ directory under
~resources/public~. Upon first run, one can once again wonder about
the sheer amount of dependencies that get loaded for this rather
simple setup.

#+begin_src sh
  npx shadow-cljs compile :frontend
#+end_src

This command might take some time and should end with messages stating
that the ~:frontend~ build is completed. It is then possible to reload
the page at http://localhost:8123/index.html (if a repl with the
server is still running, otherwise start the repl and the server again
~ if asked choose leiningen, not shadow-cljs, as the command to run)
and see the application running. Push the 'Push Me' button a few times
and inspect the SPA's behavior.

** TODO ----  QRT QRT QRT ---- CONTINUE FROM HERE --
** user namespace under dev for helper functions

When a clojure repl starts, if a user namespace is found in the root
of the class path it will get auto-loaded. We added the "dev"
directory as a source-path in project.clj. Add the following
~~/playground/product-ui/dev/user.clj~ clojure file.

#+begin_src clojure
  (ns user
    (:require [shadow.cljs.devtools.server :as shadow-server]
              [shadow.cljs.devtools.api :as shadow]))

  (defn start-cljs-repl
    []
    (shadow-server/start!)
    (shadow/watch :frontend)
    (shadow/repl :frontend))

  (defn build-cljs-release
    []
    (shadow/release :frontend))
  #+end_src

~start-cljs-repl~ allows us to launch shadow-cljs in watch mode to
recompile our clojurescript files each time they are saved, and have
the new code hot-loaded in the browser. It then switches to a
clojurescript repl. Let's try it.

If you have a repl running in the project stop it now and open the
server.clj file in the project. Launch a new repl. Select ~lein~ for
the repl type if asked. The clojure repl starts in the
product-ui-backend-server namespace. Let's start the http server,
evaluate the following in the repl.

#+begin_src clojure
  (def server (start-server))
#+end_src

Even though our repl starts in the avg-sample-site.backend-server
namespace, the user namespace should already be loaded. Try therefore
the following from the repl.

#+begin_src clojure
  (user/start-cljs-repl)
#+end_src

We should end up in a clojurescript repl, the prompt should show
something like ~cljs.user>~. Reload http://localhost:8123/index.html
in the browser and we should be connected. Test the following in the
cljs repl.

#+begin_src clojurescript
  (+ 1 2 3)
  ;; -> 6

  (= 1 1.0)
  ;; -> true
#+end_src

The last expression evaluating to true is a sign of the code being
executed on the javascript engine in the browser. javascript only has
a floating point numeric type. In clojure on the jvm the result would
be ~false~. Try the following as well.

#+begin_src clojurescript
  (js/alert "Hello")
#+end_src

All standard javascript functions and objects (from the 'window' root)
are available via the ~js/~ prefix.

** Improving code hot reloading

Try to open the style.css file and make a change. When saving the file
the changes should be immediately observable in the browser
application.

Now open the app.cljs file and change the buttons label from "Push Me"
to "Push You" and save the file. A small icon shortly shows that
shadow-cljs pushed updates to the browser, but our button isn't
updated.

Now in app.cljs, make a minor change to the definition of the init
function, adding some metadata to the var. init should look like this.

#+begin_src clojurescript
  (defn ^:dev/after-load init
    []
    (reagent-dom/render [app] (js/document.getElementById "app")))
#+end_src

And save the file again. This time our updates become visible in the
browser, including the changed "Push You" button. The metadata informs
shadow-cljs to invoke the function after a code reload, thereby
re-rendering the root ~app~ component. Now our dynamic development
environment is set up.

** share code between clj/cljs
cljc files can be compiled in a clojure or a clojurescript context, or
in both. We would probably keep our domain logic in a separate project
so that we can reuse it in other backend services, but we can
demonstrate it here by adding a new ~domain.calculations~ namespace.
Add the ~~/playground/product-ui/src/domain/calculations.cljc~ file.

#+begin_src clojure
  (ns domain.calculations)

  (defn average
    [& nums]
    (if (seq nums)
      (double (/ (reduce + nums)
                 (count nums)))
      0))
#+end_src

Save and evaluate the file, and go back to the app.cljs file. Add a
requirement to the namespace ~[domain.calculations :as calcs]~ and
change the ~current-count~ expression in the H1 content to become
~(calcs/average current-count 200)~, so the line becomes.

#+begin_src clojure
  [:h1 (str text " -- " (calcs/average current-count 200))]
#+end_src

When saving the file, the count in the header changes immediately, and
no state was lost in the process. Pressing the button a few times and
then reverting the last code change shows that the counter value and
the title text are still the same as before hot loading the new code.

We can also directly use the generated javascript from the browser js
console. Just type ~domain.calculations.average(3, 4)~ and press
enter, javascript answers ~3.5~.

** Getting back to the clojure repl
Type ~:cljs/quit~ in the clojurescript repl. You'll be back in the
clojure repl. You could now from the repl run ~(require
'[domain.calculations :as calcs])~ and test if the namespace also
works in clojure/java land ~(calcs/average 3 4)~.

** release build
Until now, the main.js file served by our application isn't minimized,
and lots of other artifacts have been generated to enable the
development experience. Being back in the clojure repl type

#+begin_src clojure
  (user/build-cljs-release)
#+end_src

Shadow cljs recompiles all of our clojurescript code and hands it,
together with javascript from included packages, of to the google
~closure~ javascript-to-javascript compiler that treats it with
advanced compilation. When the step is completed, refresh the app in
the browser and inspect the javascript file that is served now. A
single minified main.js file containing all of the logic we used from
clojurescript, react, etc...

Go to a terminal window in the root of the project and execute the
following.

#+begin_src sh
  npx shadow-cljs release :frontend
  lein uberjar
#+end_src

The first line is superfluous at the moment, it does the same thing we
just did from the clojure repl, but now via the shadow-cljs node
package. leiningen then builds a standalone uberjar, creating a single
artifact for our application server. Make sure that the clojure repl
is stopped, as we want to run the created uberjar and it will try to
use port 8123 that we hard-coded. Try refresh the app in the browser
and you should get an error about a refused connection on localhost.
Now run the following.

#+begin_src sh
  java -jar target/uberjar/product-ui-0.1.0-SNAPSHOT-standalone.jar
#+end_src

The app is up and running again, press <enter> to stop the server
again.

** The shadow-cljs UI
shadow-cljs hosts its own server at http://localhost:9630 where it
shows details about the processes and builds it is running. The
~Inspect Stream~ and ~Inspect Latest~ tabs work as tap sinks (see
clojure ~tap>~ function). Using ~tap>~ from either a clojure or
a clojurescript context will result in the values tapped being shown
in the UI, ready for inspection.

* TODO Add Ajax behavior
* TODO Add 'build uberjar' script
